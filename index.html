<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8" />
        <title>frac-js</title>

        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.3/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.3.3/dist/leaflet.js" integrity="sha512-tAGcCfR4Sc5ZP5ZoVz0quoZDYX5aCtEm/eu1KhSLj2c9eFrylXZknQYmxUssFaVJKvvc0dJQixhGjG2yXWiV9Q==" crossorigin=""></script>
      <style>

        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        </style>

    </head>
    <body onload="go()">
        <div id="map"></div>

        <script>

const workDistribution = function(options){
    const queue = [];
    const pool = [];
    if (!options) options = {};

    // set up workers
    for (var i = 0; i < (options.concurrency || 4); i++){
        const worker = new Worker(options.src);
        worker.onmessage = function(e){
            worker.working = false;
            if (options.oncomplete) options.oncomplete(e);
            schedule();
        };
        worker.working = false;
        pool.push(worker);
    }

    // execute the next item of work
    const schedule = function(){
        if (!queue.length) return;
        const nextWorker = pool.filter(x => !x.working)[0]
        if (!nextWorker) return;
        var item = queue.pop();
        nextWorker.working = true;
        nextWorker.postMessage(item);
    }

    return {
        push : function(item, cb){
            queue.push(item);
            schedule();
        }
    };
}

const options = {
    centre: [-128,128],
    tileSize : 256,
    // precision is lost at any greater level
    depth : 48  
}

const canvases = {};
var id = 0;

function workerComplete(event){
    var c = canvases[event.data.id]
    if (!c){ return;}

    c.ctx.putImageData(event.data.imageData, 0, 0);
    c.tile.src = c.canvas.toDataURL();
    delete canvases[event.data.id];
}

function go(){
    var workPoolManager = workDistribution({
        oncomplete : workerComplete,
        concurrency : navigator.hardwareConcurrency,
        src : 'worker.js'
    });
        
    const map = L.map('map', {crs: L.CRS.Simple}).setView(options.centre, Math.min(2, options.depth));

    L.TileLayer.Mandlebrot = L.TileLayer.extend({
        getAttribution: function() {
            return "<a href='https://github.com/richorama/frac-js'>frac-js</a>"
        },
        createTile:function(coords, done){
            const tile = document.createElement('img');

            L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
            L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));

            if (this.options.crossOrigin) {
                tile.crossOrigin = '';
            }

            tile.alt = '';
            tile.id = (id++).toString();
            tile.setAttribute('role', 'presentation');

            const canvas = document.createElement("canvas");
            canvas.width = options.tileSize;
            canvas.height = options.tileSize;
            const ctx = canvas.getContext("2d");
            const imageData = ctx.getImageData(0, 0, options.tileSize, options.tileSize);

            canvases[tile.id] = {
                canvas:canvas,
                ctx:ctx,
                tile:tile
            };

            workPoolManager.push({coords:coords, id:tile.id, imageData:imageData});
            return tile;
        }
    });

    L.tileLayer.mandlebrot = function() {
        return new L.TileLayer.Mandlebrot();
    }

    L.tileLayer.mandlebrot().addTo(map);
}

        </script>

    </body>
</html>
