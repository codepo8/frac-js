<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8" />
        <title>frac-js</title>

        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.3/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.3.3/dist/leaflet.js" integrity="sha512-tAGcCfR4Sc5ZP5ZoVz0quoZDYX5aCtEm/eu1KhSLj2c9eFrylXZknQYmxUssFaVJKvvc0dJQixhGjG2yXWiV9Q==" crossorigin=""></script>
      <style>

        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        </style>

    </head>
    <body onload="go()">
        <div id="map"></div>

        <script>

const workDistribution = function(options){
    let queue = [];
    const pool = [];
    if (!options) options = {};

    // set up workers
    for (var i = 0; i < (options.concurrency || 4); i++){
        const worker = new Worker(options.src);
        worker.working = false;
        pool.push(worker);
    }

    // execute the next item of work
    const schedule = function(){
        if (!queue.length) return;
        const nextWorker = pool.filter(x => !x.working)[0]
        if (!nextWorker) return;

        var work = queue.pop();
        nextWorker.working = true;
        nextWorker.onmessage = function(e){
            nextWorker.working = false;
            work.cb(e);
            schedule();
        }
        nextWorker.postMessage(work.item);
        
    }

    return {
        push : function(item, cb){
            queue.push({item:item, cb:cb});
            schedule();
        }
    };
}

const options = {
    centre: [-128,128],
    tileSize : 256,
    depth : 48 // precision is lost at any greater level
}


function go(){
    var workPoolManager = workDistribution({
        concurrency : navigator.hardwareConcurrency,
        src : 'worker.js'
    });
        
    const map = L.map('map', {crs: L.CRS.Simple, maxZoom : options.depth}).setView(options.centre, 2);

    L.TileLayer.Fractal = L.TileLayer.extend({
        initialize:function(){
            this.on('tileunload', e => e.tile.removed = true);
        },
        setType:function(value){
            this._type = value;
        },
        getAttribution: function() {
            return "<a href='https://github.com/richorama/frac-js'>frac-js</a>"
        },
        createTile:function(coords, done){
            const tile = document.createElement('img');

            L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
            L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));
          
            if (this.options.crossOrigin) tile.crossOrigin = '';

            tile.alt = '';
            tile.setAttribute('role', 'presentation');

            workPoolManager.push({coords:coords, id:tile.id, type : (this._type || 'mandlebrot')}, (e) => {
                if (tile.removed) return; // don't bother, this tile has been removed

                const canvas = document.createElement("canvas");
                canvas.height = canvas.width = options.tileSize;

                const ctx = canvas.getContext("2d");
                ctx.putImageData(event.data.imageData, 0, 0);

                tile.src = canvas.toDataURL();
    
            });
            return tile;
        }
    });

    L.tileLayer.mandlebrot = () => {
        var layer = new L.TileLayer.Fractal();
        layer.setType('mandlebrot');
        return layer;
    }
    
    const mandlebrot = L.tileLayer.mandlebrot().addTo(map);

    L.tileLayer.julia = () => {
        var layer = new L.TileLayer.Fractal();
        layer.setType('julia');
        return layer;
    }
    
    const julia = L.tileLayer.julia();


    L.control.layers({mandlebrot, julia}).addTo(map);
}

        </script>

    </body>
</html>
